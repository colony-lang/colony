//
// integers
//
x := 1i8
y: i8 = 2_i8

z: i8 = x + y
z: i8 = x.__type__.__add__(x, y)

w := x + y * z
w := x + (y * z)
w := x.__type__.__add__(x, y.__type__.__mul__(y, z))

//
// struct/union
//
A := (__type__:=struct, __fields__:=(x: i32=0), __funcs__:=(add:=(self, other) -> { A(self.x + other.x) }))

A := struct(
    x: i32=0,
    
    add := (self, other) -> {
        A(self.x + other.x)
    }
)

B := (__type__:=struct, __fields__:=(x: f32=0.0))
B := struct(x: f32=0.0)

C := (__type__:=union, __types__:=[A, B])
C := A | B

c0: C = A(-1)
c1: C = B(-1.0)

//
// bases
//
A := struct(
    __name__:='A',
    x: i32=0,
    
    add := (self: Self, other: Self) -> {
        A(self.x + other.x)
    }
)

B := struct(
    __name__:='B',
    __bases__:=[A],
    y: i32=0,

    add := (self: Self, other: Self) -> {
        B(self.x + other.x, self.y + other.y)
    }
)

b0: B = B(1, 2)
b1: B = B(2, 3)
b2: B = b0.add(b1)
b2: B = b0.__type__.add(b0, b1)
b2: B = getattr(b0, 'add')(b1)

//
// generics
//
A := struct[T=number](
    x: T = T.default_value,
    
    __add__ := (self: Self, other: Self) -> Self {
        A[T](self.x + other.x)
    }
)

A_i32: struct = A[i32]
a0 := A_i32(-1)

a1: A = A[i32](-1)
a2: A = A[i32](-2)
a3: A = a1 + a2
a3: A = a1.__type__.__add__(a1, a2)
a3: A = getattr(a1, '__add__')(a2)

//
// type ??? unfinished
//
type := (
    __type__: type = type,
    __name__: str = 'type',
    __bases__: array[type] = [object],

    __init__ := (cls: Self, [args], {kwargs}) -> Self {
        cls
    },

    __call__ := (cls: Self, [args], {kwargs}) -> Self {
        self: cls = (__type__: type=cls)
        self
    },

    __getattr__ := (cls: Self, key: Any) -> Any {

    },
)

object := (
    __type__: type = type,
    __name__: str = 'object',
    __bases__: array[type] = [],

    __init__ := (self: Self, [args], {kwargs}) -> Self {
        self
    },
)
