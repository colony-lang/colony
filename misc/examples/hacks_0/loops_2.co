//
// generator / iterator ???
//
// generator := <T:=type> -> (f: fn) -> generator<T> -> { ... }

generator: struct = <T:=type> -> (
    ResType: type = T,
    __type__ := (
        // __init__ := () ...
    ),
)

g: generator<int> = generator<int>((i: int) -> int -> {
    s := yield(i)
    i += s
})

it: iterator<int> = g(0)
it, v := it(2)
v == 0
it, v := it(2)
v == 2
it, v := it(2)
v == 4

//
// generator / iterator 1
//
g: generator<int> = generator<int>(
    (i: int) -> int -> {
        r := i < 10 ? {
            v := yield(i)
            i += v
        } : {
            return()        // stops generator
        }

        r
    }
)

it: iterator<int> = g(0)

f: loop<int> = loop<int>(
    (i: int) -> int -> {
        it: iterator<int>, v: int = it.next(1)
        
        match(it)
            .case(None, () -> {
                break()     // breaks last loop function
            })
        
        print(v)
        v
    }
)

r: int = g(10).map((i) -> { i }).len()
r == 10

r: int = f(10)
r == 10

//
// range generator 2
//
range: generator<int> = generator<int>(
    (b: int, e: int, s: int=1) -> int -> {
        i := b

        i < e ? {
            yield(i)
            i += s
        } : {
            return()         // stops generator
        }
    }
)

r := range(0, 10, 2).map((i) -> { i })
r == [0, 2, 4, 6, 8]
