// <T: i64|f64> == <T: i64|f64=i64>
// (x: T) == (x: T=T.default)
X: type = <T: i64|f64> -> (x: T)
Y: type = <T: i64|f64> -> (y: T)
Z: type = <T: i64|f64> -> (z: T)

//
// composition via currying
//
P: type = X<f64> -> Y<f64> -> Z<f64>
p: P = P(1.0)(2.0)(3.0)
p.x == 1.0
p.y == 2.0
p.z == 3.0

//
// product type aka record/struct
//
P: type = X<f64> & Y<f64> & Z<f64>
p: P = P(1.0, 2.0, 3.0)
p.x == 1.0
p.y == 2.0
p.z == 3.0

//
//
//
A: type = <T: i64|f64> -> (x: T, y: T)

A_0: type_chain(<T: i64|f64>, (x: T, y: T)) = A<i64>
type_chain(<T: i64|f64>, (x: T, y: T))(i64) == A<i64>

//
//
//
A: type = <T: i64|f64=i64> -> interface(
    __add__ = (self, other: Self) -> Self {
        res: Self = Self(self.x + other.x, self.y + other.y)
        res
    },
     __sub__ = (self, other: Self) -> Self {
        res: Self = Self(self.x - other.x, self.y - other.y)
        res
    },
) -> (
    x: T,
    y: T,
)

a0: A = A<i64>(1, 2)
a1: A = A<i64>(2, 3)
a2: A = a0 + a1
a3: A = a0 - a1

//
//
//
Add2D := interface(
    __add__ = (self, other: Self) -> Self {
        res: Self = Self(self.x + other.x, self.y + other.y)
        res
    },
)

Sub2D := interface(
    __sub__ = (self, other: Self) -> Self {
        res: Self = Self(self.x - other.x, self.y - other.y)
        res
    },
)

A: type = <T: i64|f64=i64> -> (Add2D & Sub2D) -> (
    x: T,
    y: T,
)

a0: A = A<i64>(1, 2)
a1: A = A<i64>(2, 3)
a2: A = a0 + a1
a3: A = a0 - a1
