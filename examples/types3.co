
type Object {
    /*
    __type__: Type = Type
    __bases__: List[Type] = []
    __name__: str = "Object"
    
    __fields__: Dict<str, List<Type, Object>> = {} // field_name: field_type = field_default_value
    
    __funcs__: Dict<str, Fn> = {
        "__new__": ...,
        "__init__": ...,
        "__del__": ...,
        "__repr__": ...,
        "__getattr__": ...,
        "__setattr__": ...,
    }
    */
    fn __new__(tp: Type, [args], {kwargs}) -> __type__ {
        let self: tp = {
            .__type__: tp,
            ...tp.__fields__
                 .items()
                 .slice(0, args.len())
                 .zip(args)
                 .map(fn (field: List<str, List<Type, Object>>, arg: Object): [field[0], arg])
                 .dict(),
            ...kwargs
        }

        self
    }

    fn __init__(self: __type__, [args], {kwargs}) -> __type__ {
        self
    }

    fn __del__(self: __type__) {
        // pass
    }

    fn __repr__(self: __type__) -> str {
        "<{} at {}>".format(self.__type__.__name__, addressof(self))
    }
}

type Type: Object {
    /*
    __type__: Type = Type
    __bases__: List[Type] = [Object]
    __name__: str = "Type"

    __fields__: Dict<str, List<Type, Object>> = {} // field_name: field_type = field_default_value

    __funcs__: Dict<str, Fn> = {
        "__call__": ...,
    }
    */
    fn __call__(tp: Type, [args], {kwargs}) -> Type {
        let self: tp = tp.__new__(...[args], ...{kwargs})
        self = self.__init__(...[args], ...{kwargs})
        self
    }
}

type Fn: Object {
    fn __get__(self: Fn, owner: Object) -> Fn {
        match owner {
            Type -> fn ([args], {kwargs}) -> Object {
                self(...args, ...kwargs)
            }
            _ -> fn ([args], {kwargs}) -> Object {
                self(owner, ...args, ...kwargs)
            }
        }
    }
}

fn getattr(obj: Object, attr: str) -> Object {
    let value: Option<Object> = obj.__type__[attr]
    
    // TODO
    match value {
        Some { v } -> {}
        None -> {
            
        }
    }

    value
}

fn setattr(obj: Object, attr: str, value: Object) -> Object {
    // TODO
}

// type "A" is derived from "Object"
// NOTE: all types are by defauly derived from "Object"
//       so developer does not need to manually derive it
type A: Object {
    /*
    __type__: Type = Type
    __bases__: List[Type] = [Object]
    __name__: str = "A"
    
    __fields__: Dict<str, List<Type, Object>> = {
        .x: [i32, i32.default()],
        .y: [i32, 0],
    }
    
    __funcs__: Dict<str, Fn> = {
        "__init__": fn ... ,
        "__add__": fn ... ,
        "add": fn ... ,
    }
    */
    x: i32
    y: i32 = 0

    fn __init__(self: A, x: i32=0, y: i32=0) -> A {
        self.x = x // self = self.__setattr__('x', x)
        self.y = y // self = self.__setattr__('y', y)
        self
    }

    fn __add__(self: A, other: A) -> A {
        let res: A = A(self.x + other.x, self.y + other.y)
        res
    }

    fn add(self: A, other: A) -> A {
        self.__add__(other)
    }
}

// let _target = A
// let _func = getattr(_target, "__call__")
// let a0: A = _func(...[0], ...{.y: 1})
let a0: A = A(0, y=1)
let a1: A = A(0)
let a2: A = A()

// destructure object
let [0: x0, 1: y0, [rest]] = a0
let {x: x1, y: y1, {rest}} = a1
let {x, y} = a2

// let _target = a0
// let _func = getattr(_target, "__add__")
// let a3: A = _func(a1)
let a3: A = a0 + a1

// let _target = a0
// let _func = getattr(_target, "add")
// let a4: A = _func(a1)
let a4: A = a0.add(a1)
