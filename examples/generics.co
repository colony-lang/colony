//
// partial-like function call
//
f = a: int -> fn[int, int] {
    b: int -> int {
        a + b
    }
}

f1 = f 1
r0 = f1 2
r0 == 3

f = a: int -> b: int -> int { a + b }
f1 = f 1
r0 = f1 2
r0 == 3

//
// object/type
//
object: mut.dict = mut.dict() // mut is core module containing mutable implementations of list/dict
type: mut.dict = mut.dict()

// object
object.__type__ = type 
object.__name__ = "object"
object.__fields__ = {"__type__": type} // {field_name: field_type}
object.__generics__ = None

object.__new__ = (cls: type, [args], {kwargs}) -> object {
    // create empty typed object without initialized fields
    self: cls = {
        .__type__: cls,
    }

    self
}

object.__init__ = (self: object, [args], {kwargs}) -> object {
    // create object with initialized fields from passed args and kwargs
    args_fields: dict = dict(zip(self.__fields__.keys().slice(0, args.len()), args))
    kwargs_fields: dict = self.__fields__.slice(args.len(), self.__fields__.len()) + kwargs
    self += args_fields + kwargs_fields
    self
}

object.__repr__ = (self: object) -> str {
    "{" + self.map((k, v) -> "{}: {}".format(repr(k), repr(v))).join(",") + "}"
}

// type
type.__type__ = type
type.__name__ = "type"
type.__fields__ = {"__type__": type}
type.__generics__ = None

type.__new__ = (mcs: type, [args], {kwargs}) -> type {
    // create empty typed object without inialized fields
    cls: type = {
        .__type__: mcs,
    }

    cls
}

type.__init__ = (cls: type, [args], {kwargs}) -> type {
    // init type
    cls = (cls + kwargs)
    cls
}

type.__call__ = obj: dict | (cls: type, [args], {kwargs}) -> object {
    // creates instance of cls type
    match(obj,
        dict -> {
            cls: type = type["__new__"](type, ...[], ...{})
            cls = type["__init__"](cls, ...[], ...obj)
            cls
        },
        _ -> {
            {cls, args, kwargs} = _ // destructuring assignment
            self: cls = cls["__new__"](cls, ...args, ...kwargs)
            self = cls["__init__"](self, ...args, ...kwargs)
            self
        }
    )
}

type.__getitem__ = (cls: type, [gentypes]) -> type {
    // create new type with generics types set
    cls = {
        ...cls,
        .__generics__: dict(zip(self.__generics__.keys(), gentypes)),
    }
    
    cls
}

// finalize object and type as immutable types
object: type = type.inplace_imut()
type: type = type.inplace_imut()

//
// custom type 1
//
A = type {
    .x: int,
    .y: int,
    .z: int,
    
    .add: (self: A, other: A) -> A {
        res: A = A(
            self.x + other.x,
            self.y + other.y,
            self.z = other.z,
        )

        res
    },
}

a0: A = A(1, 2, 3)
a1: A = A(2, 3, 4)
a2: A = a0 + a1

//
// generics example 1
//
A = type {
    // generics
    .__generics__: {
        .K: object,
        .V: object,
    },
    
    .items: dict[K, V], // K and V are vars from __generics__
    
    .__init__: (self, items: dict[K, V]) -> A {
        self.items = items
        self
    },
    
    .__add__: (self, other: A) -> A {
        res: A = A(self.items + other.items)
        res
    },
    
    .set: (self, key: K, value: V) -> {
        self = (self.items[key] = value)
        self
    },
}

a0: A = A[str, int]()
a1: A = A[str, int]()
a2: A = a0 + a1

//
// generics example 2
//
generics: fn = t: dict[str, Option[object]] -> type {
    cls: type = {
        .__type__: type,
        .__generics__: dict(
            zip(t.keys(), t.values()).map((k, v) -> {
                [k, match(v, None -> { object }, _ -> v)]
            })
        ),
    }

    cls
}

A = generic {.K, .V} {
    .items: dict[K, V],
}

