//
// object based
//
object: mut_dict = mut_dict()
object: mut_dict[str, object] = object
type: mut_dict[str, object] = mut_dict()

object += {
    .__type__: type,
    .__name__: "object",
    .__bases__: [],
    .__new__: (cls: type, [args], {kwargs}) -> Self {
        Fields: type = dict[str, object]
        classes: list[type] = cls.__bases__ + [cls]

        bases_fields: list[Fields] = classes.map((b: type) -> Fields {
            b.filter((k: str, v: object) -> {
                !k.ismeta() && !callable(v)
            })
        })

        fields: Fields = bases_fields.reduce((acc: Fields, n: Fields) -> Fields {
            acc + n
        }, {})

        self: cls = {
            .__type__: cls,
            ...fields
        }

        self
    },
    .__init__: (self: Self, [args], {kwargs}) -> Self {
        self
    },
    .__repr__: (self: Self) -> str {
        "<%s at %x>".format(self.__type__.__name__, self.__type__.__getaddress__(self))
    },
    .__getaddress__: (self: Self) -> uint {
        // native code that gets address of obj
    }
}

type += {
    .__type__: type,
    .__name__: "type",
    .__bases__: [object],
    .__call__: (obj: (type | dict[str, object]), [args], {kwargs}) -> object {
        match(obj, 
            type -> object {
                // create instance
                self: obj = obj.__new__(obj, ...args, ...kwargs)
                self = self.__init__(self, ...args, ...kwargs)
            },
            dict[str, object] -> type {
                // create class
                cls: type = _
                cls, name: str = cls.pop("__name__", "type-%s".format(uuid4()))
                cls, bases: list[type] = cls.pop("__bases__", [object])
                bases = bases.has(object) ? bases : bases + [object]

                cls = {
                    .__type__: obj,
                    .__name__: name,
                    .__bases__: bases,
                    ...cls
                }
            }
        )
    }
}

type = type.inplace_imut()
type: type = type
object: type = object.inplace_imut()

//
A = type {
    .x: int(0),
    .y: int(0),
    .z: int(0),
    .__init__: (self: Self, x: int, y: int) -> Self {
        // self = (((self.x = x).y = y).z = x + y)
        // self = self + {.x: x, .y: y, .z: x + y}
        // self += {.x: x, .y: y, .z: x + y}
        // self = (self.x = x) + (self.y = y) + (self.z = x + y)
        self = (self.x = x)
        self = (self.y = y)
        self = (self.z = x + y)
    },
    .__add__: (self: Self, other: Self) -> Self {
        Self(self.x + other.x, self.y + other.y)
    }
}

a0: A = A(1, 2, 3)
a0: A = A.__call__(A, 1, 2, 3)

a1: A = A(2, 3, 4)
a1: A = A.__call__(A, 2, 3, 4)

a2: A = a0 + a1
a2: A = A.__add__(a0, a1)
a2: A = a0.__add__(a0, a1)
a2: A = a0.__type__.__add__(a0, a1)
