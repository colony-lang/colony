//
// auto initialization
//
v0: int
v0 == 0

//
// manual initialization
//
v1: int = 0
v1 == 0

//
// single param function only
//
f0 = int -> int {
    _ + 2
}

r0: int = f0 1
r0 == 3

//
// tuple - anonymous product type
//
T: (int, int)
v: T = (1, 2)

// assignment by destruction
a: int, b: int = v
a: int, b: int = v[0], v[1]

//
// tuple - product type
//
T: (x: int, y: int)
v: T = (x=1, y=2)

// assignment by destruction
x: int, y: int = v
x: int, y: int = v.x, v.y
x: int, y: int = v[0], v[1]

//
// union - anonymous sum type
// types should not repeat, last overwrites last prop with same type
//
T: (int | float)
v0: T = 10
v1: T = -2.0

//
// union - sum type
// types should not repeat, last overwrites last prop with same type
//
T: (x: int | y: float)
v0: T = 10
v1: T = -2.0

//
// match - structural pattern matching
//
T: type = (int, int)
U: type = (x: int, y: int)
V: type = (int | float)
W: type = (x: int | y: float)
P: type = T | U | V | W

a: T = (1, 2)
b: U = (2, y=3)
c: V = (1, 2.0)
d: W = (2, 3.0)
e: P + random.choice([a, b, c, d])

Q: type = (x: int | float, y: int | float)

r: Q = type(e) == T ? {
        x: int, y: int = e
    } : type(e) == U ? {
        x: int, y: int = e
    } : type(e) == V ? (
        type(e) == V[0] ? {
            x: int = e
            y: float = 0
        } : type(e) == V[1] ? {
            x: int = 0
            y: float = e
        }
    ) : type(e) == W ? {
        type(e) == W.x ? {
            x: int = e
            y: float = 0
        } : {
            x: int = 0
            y: float = e
        }
    }

r: Q = match(
    e,
    T -> Q { x: int, y: int = e },
    U -> Q { x: int, y: int = e },
    V -> Q { x: int, y: float = e, 0 },
    W -> Q { x: int, y: float = 0, e },
)

//
// tuple as param type of function
//
f0 = (int, int) -> int {
    _[0] + _[1]
}

a0: (int, int) = (1, 2)
r0: int = f0 a0
r0 == 3

r1: int = f0(1, 2)
r1 == 3

//
T: type = (int, int)

f0 = T -> int {
    _[0] + _[1]
}

a0: T = (1, 2)
r0: int = f0 a0
r0 == 3

//
// object based
//
object: dict = {}.mut()
type: dict[str, object] = {}.mut()

object += {
    .__type__: type,
    // .__name__: "object-%s".format(uuid4()),
    .__name__: "object",
    .__bases__: [],
    .__new__: (cls: type, [args], {kwargs}) -> Self {
        self: cls = {
            .__type__: cls,
            ...{cls.filter((k, v) -> { !k.isdunder() })}
        }
    },
    .__init__: (self: Self, [args], {kwargs}) -> Self {
        self
    },
}

type += {
    .__type__: type,
    .__name__: "type",
    .__bases__: [object],
}

type = type.inplace_imut()
type: type = type
object: type = object.inplace_imut()

A = type {
    .x: int(0),
    .y: int(0),
    .__init__: (self: Self, x: int, y: int) -> Self {
        // self = ((self.x = x).y = y)
        // self = self + {.x: x, .y: y}
        // self += {.x: x, .y: y}
        // self = (self.x = x) + (self.y = y)
        self = (self.x = x)
        self = (self.y = y)
    }
}

