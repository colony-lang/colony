//
// object/type - implemented low-level in C
//
object := MutTuple()
type := MutTuple()

object.__type__: type = type
object.__name__: str = 'object'
object.__generics__: list[str] = []
object.__bases__: list[type] = []
object.__fields__: tuple = ()
object.__functions__: dict[str, callable] = {}

type.__type__: type = type
type.__name__: str = 'type'
type.__generics__: list[str] = []
type.__bases__: list[type] = [object]
type.__fields__: tuple = ()
type.__functions__: dict[str, callable] = {}

object.__functions__.__new__ = (cls: type) -> object {
    // implemented as native code
    pfields = _.__pfields__
    kwfields = _.__kwfields__

    self: object = (
        __type__: type=cls,
        ...zip(cls.__fields__.keys(), cls.__fields__.types(), pfields),
        ...kwfields.items().slice(pfields.len(), kwfields.len()),
    )

    self
}

object.__functions__.__free__ = (self: object) -> object {
    // implemented as native code
    //  frees dependent resources
    //  after this call, `self` is freed by memory allocator
}

object.__functions__.__repr__ = (self: object) -> str {
    // implemented as native code
    res: str = '<{} at {}>'.format(self.__type__.__name__, addressof(self))
    res
}

type.__functions__.__new__ = (mcs: type, name: str, generics: list[str], bases: list[type], fields: dict[str, object], functions: dict[str, object]) -> type {
    // implemented as native code
    cls: object = (
        __type__: type = mcs,
        __name__: str = name,
        __generics__: list[str] = generics,
        __bases__: list[type] = bases,
        __fields__: tuple = fields,
        __functions__: dict[str, callable] = functions,
    )

    cls
}

type.__functions__.__call__ = (obj: object) -> object {
    // implemented as native code
    match(
        obj,
        (cls: type, name: str) -> type {
            // name
            {
                ...cls,
                .__name__: name,
            }
        },
        (cls: type, generics: list[str]) -> type {
            // generics
            {
                ...cls,
                .__generics__: dict(zip(generics, generics.map(n => object))),
            }
        },
        (cls: type, bases: list[type]) -> type {
            // bases or specific
            cls.__generics__ ? {
                // specific
                {
                    ...cls,
                    .__generics__: dict(zip(cls.__generics__.keys(), bases)),
                }
            } : {
                // bases
                {
                    ...cls,
                    .__bases__: [object] + bases,
                }
            }
        },
        (cls: type, fields_and_functions: dict[str, object]) -> type {
            // fields and functions
            {
                ...cls,
                .__fields__: dict(fields_and_functions.filter((k, v) => !iscallable(v))),
                .__functions__: dict(fields_and_functions.filter((k, v) => iscallable(v))),
            }
        },
        (cls, type, [args], {kwargs}) -> object {
            // instance
            self: cls = cls.__functions__.__new__(cls, ...args, ...kwargs)
            self
        }
    )
}

object.freeze()
type.freeze()

//
// user-defined type using generics
//
// Q = type (
// Q = type ['X', 'Y'] (
// Q = type 'Q' ['X', 'Y'] (
Q = type 'Q' ['X', 'Y'] [object] (
    x: X,
    y: Y,

    __add__ := (self: Q, other: Q) -> Q {
        res: Q = Q[X, Y](x=self.x + other.x, y=self.y + other.y)
        res
    },

    __sub__ := (self: Q, other: Q) -> Q {
        res: Q = Q[X, Y](x=self.x - other.x, y=self.y - other.y)
        res
    },

    add := (self: Q, other: Q) -> Q {
        res: Q = self + other
        res
    },
)

q0: Q = Q[float, float](1.0, 2.0)
q1: Q = Q[float, float](2.0, 3.0)
q2: Q = q0.add(q1)
q3: Q = q0 + q1
