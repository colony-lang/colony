//
// object / type
//
object = MutDict()
type = MutDict()

object.__type__ = type
object.__bases__ = []
object.__name__ = 'object'
object.__fields__ = {}

object.__funcs__ = {
    .__new__: (cls: type, [args], {kwargs}) -> object {
        self = {.__type__: cls}
        self
    },

    .__init__: (self: object, [args], {kwargs}) -> object {
        self = {...self} // TODO: init from args and kwargs
        self
    },

    .__repr__: (self: object) -> str {
        res: str = '<{} at {}>'.format(self.__type__.__name__, addressof(self))
        res
    },
}

type.__type__ = type
type.__bases__ = [object]
type.__name__ = 'type'
type.__fields__ = {}

type.__funcs__ = {
    .__call__: (obj: object, [args], {kwargs}) -> object {
        istypeof(obj, tuple) ? {
            cls: type = obj

            cls__new__ = getattr(cls, '__new__')
            self = cls__new__(cls, ...args, ...kwargs)

            self__init__ = getattr(self, '__init__')
            self = self__init__(self, ...args, ...kwargs)
            
            self
        } : {
            mcs: type = obj
            
            cls: type = {} // TODO: implement type definition
            cls
        }
    },

    .__getitem__: (cls: type, [args]) -> type {
        // TODO: generics
        cls
    },
}

object.inplace_imut()
type.inplace_imut()

//
// examples
//
/*
    P: type = {
        .__type__: type,
        .__bases__: [object],
        .__name__: 'type_0xbeef', // random name
        .__fields__: {
            .x: int(0),
            .y: int(0),
        },
        .__funcs__: {
            .__add__: (self: P, other: P) -> P {
                res: P = P(x=self.x + other.x, y=self.y + other.y)
                res
            },

            .add: (self: P, other: P) -> P {
                res: P = self + other
                res
            },
        },
    }
 */
P = type 'P' [] {
    .x: int(0),
    .y: int(0),
    
    .__add__: (self: P, other: P) -> P {
        res: P = P(x=self.x + other.x, y=self.y + other.y)
        res
    },

    .add: (self: P, other: P) -> P {
        res: P = self + other
        res
    },
}

/*
    p0: P = {.__type__: P, .x: 1, .y: 2}
    p1: P = {.__type__: P, .x: 2, .y: 3}
 */
p0: P = P(x=1, y=2)
p1: P = P(x=2, y=3)

/*
    p2: P = p0.__type__.__funcs__.add(p0, p1)
 */
p2: P = p0.add(p1)

/*
    p3: P = p0.__type__.__funcs__.__add__(p0, p1)
 */
p3: P = p0 + p1
