
A := <T: type> -> (
    __name__ := 'A',
    __new__ := (cls, x: T, y: T) -> Self {
        Self(
            r0 = R<T>(x, y),
            r1 = R<T>(x + 1, y + 1),
        )
    },
    new_with_rs := (cls, r0: R<T>, r1: R<T>) -> Self (
        Self(
            r0 = r0,
            r1 = r1,
        )
    ),
    mul := (self, v: T) -> Self {
        Self(
            r0 = r0.mul(v),
            r1 = r1.mul(v),
        )
    },
    div := (self, v: T) -> Self {
        Self(
            r0 = r0.div(v),
            r1 = r1.div(v),
        )
    },
) -> (
    r0: R,
    r1: R,
);

R := <T: type> -> (
    __name__ := 'R',
    mul := (self, v: T) -> Self {
        Self(
            self.x * v,
            self.y * v,
        )
    },
    div := (self, v: T) -> Self {
        Self(
            self.x / v,
            self.y / v,
        )
    },
) -> (
    x: T,
    y: T,
);

a0 := A<i64>(1, 2)

// recommended
a1 := a0.mul(2)

// not recommended
a2_r0 := a0.r0.mul(2)
a2_r1 := a0.r1.mul(2)
a2 := A<i64>.new_with_rs(a2_r0, a2_r1)

// panics, not handled
a3 := a0.div(0)

// try
a3: Result<A<i64>, Error> = try(() -> a0.div(0))

// match
r := match(a3)
    .case(A<i64>, (v) -> { 1 })
    .case(ZeroDivisionError, (e) -> { 0 })
    .default(() -> { -1 })
