
//
// type
//
type := _MutDict()
type.__type__ := type
type.__name__ := 'type'

type.__call__ := (cls: type, [args], {kwargs}) -> {
    self := _MutDict()
    self.__type__ := cls
    self.update(cls.__fields__)
    self.freeze()
    self: cls = cls::__init__(self, ...args, ...kwargs)
    self
}

type.__or__ := (cls: type, o: type) -> union {
    res_union_cls: union = {
        .__type__ := union
        .__uniontypes__ := [cls, o]
    }

    res_union_cls
}

type.freeze()

//
// object
//
object: type = {
    .__type__ := type
    .__name__: str = 'object'

    .__init__ := (self, {kwargs}) -> {
        self.update(kwargs)
    }

    .__str__ := (self) -> str {
        '<{} {}>'.format([self::__type__::__name__, str::hex(addressof(self))])
    }
}

//
// union
//
union: type = {
    .__type__ := type
    .__name__ := 'union'
    
    .__getattr__ := (cls, [uniontypes]) -> union {
        res_union_cls: cls = {
            .__type__ := cls
            .__uniontypes__ := uniontypes
        }

        res_union_cls
    }

    .__call__ := (cls, [args], {kwargs}) -> Result {
        res: Result = Err("Union cannot be instantiated")
        res
    }
}

//
// A
//
A: type = {
    ...object
    .__name__ := 'A'
    
    .__fields__ := {
        .x: f32 = 0_f32
        .y: f32 = 0_f32
    }

    .__init__ := (self, x: f32, y: f32) -> A {
        self.x := x
        self.y := y
        self
    }

    .__add__ := (self, other: A) -> A {
        res: A = A(
            self.x + other.x,
            self.y + other.y,
        )

        res
    }
}

a0: A = A(1.0_f32, 2.0_f32)
a1: A = A(2.0_f32, 3.0_f32)

a0 := A.__call__(1.0_f32, 2.0_f32)
a1 := A.__call__(2.0_f32, 3.0_f32)

a0 := A::__type__::__call__(A, 1.0_f32, 2.0_f32)
a1 := A::__type__::__call__(A, 2.0_f32, 3.0_f32)

a2 := a0 + a1
a2 := a0.__add__(a1)
a2 := a0::__type__::__add__(a0, a1)
a2 := A::__add__(a0, a1)

//
// c2 := c0.add_xyz(c1)
//
Base := {
    ...object

    .add_xyz := (self, other) -> {
        cls := self.__type__
        
        res := cls(
            self.x + other.x,
            self.y + other.y,
            self.z + other.z,
        )

        res
    }
}

A := {
    ...Base

    .__fields__ := {
        .x: i32 = 0_i32
    }
}

B := {
    ...Base

    .__fields__ := {
        .y: i32 = 0_i32
    }
}

C := {
    ...A
    ...B

    .__fields__ := {
        ...A.__fields__
        ...B.__fields__
        .z: i32 = 0_i32
    }
}

c0 := C(0_i32, 1_i32, 2_i32)
c1 := C(1_i32, 2_i32, 3_i32)
c2 := c0.add_xyz(c1)

//
// C := A | B
//
Base := {
    ...object
}

A := {
    ...Base

    .__fields__ := {
        .x: i32 = 0_i32
    }
}

B := {
    ...Base

    .__fields__ := {
        .y: i32 = 0_i32
    }
}

C := A | B

C := union[A, B]

C := {
    .__type__ := union
    .__uniontypes__ := [A, B]
}

c0: C = A(0_i32)
c1: C = B(1_i32)

//
//
//
a: list[i32] = range(10_i64)

a := range(10_i64).map((i: i64) -> { i ** 2.0 })

a := range(10_i64).filter((i: i64) -> { i % 2 && i ^ 0b11 || i == 1 })

//
//
//
A := {
    ...object
    .__name__ := 'A'

    .__fields__ := {
        .x: i32 = 0_i32
        .y: i32 = 0_i32
        .z: i32 = 0_i32
    }
}

a0 = A(1_i32, 2_i32, 3_i32)
A(x, y, z) := a0

v := a0 ?? {
    A(x, y, z) ? x == 0 -> x + y + z
    A(x, y, z) ? y == 1 -> x + y + z
    A(x, y, z) ? z == 2 -> x + y + z
    A(x, y, z) -> x + y + z
}
