//
// generics - deferred function types
//

f = fn<P, R> P -> R {
    _ + 1
}

// syntactic sugar for:
f = type {
    .__name__: "fn<P,R>",
    .__gentypenames__: ["P", "R"],
    .__getitem__: (self, [param_types]) -> fn {
        param_types = param_types + range()

        __named_param_types__: dict = dict[str, type](
            zip(self.__gentypenames__, param_types)
        )
        
        typed_func: fn = __named_param_types__["P"] -> __named_param_types__["R"] {
            _ + 1
        }

        typed_func
    }
}

r = f[int, int] 0
r == 1

//
// generics - deferred custom-type types
//
A = type<R, T, S> {
    .r: Option[R],
    .t: Option[T],
    .s: Option[S],

    .__init__: (self, r: R, t: T, s: S) -> Self {
        self = (self.r = r) +
               (self.t = t) +
               (self.s = s)

        self
    }
}

// syntactic sugar for:
A = type {
    .__name__: "type<R,T,S>",
    .__gentypenames__: ["R", "T", "S"],
    .__getitem__: (self, [param_types]) -> fn {
        __named_param_types__: dict = dict[str, type](
            zip(self.__gentypenames__, param_types)
        )
        
        typed_type: type = type {
            .r: Option[__named_param_types__["R"]],
            .t: Option[__named_param_types__["T"]],
            .s: Option[__named_param_types__["S"]],

            .__init__: (
                self,
                r: __named_param_types__["R"],
                t: __named_param_types__["T"],
                s: __named_param_types__["S"]
            ) -> Self {
                self = (self.r = r) +
                       (self.t = t) +
                       (self.s = s)

                self
            }
        }

        typed_type
    }
}

a0: A = A[i8, i8, i8](0, 1, 2)

//
// enum ???
//
enum = type<[gentypes]> {
    .__name__: "enum",
    .__typevariants__: [],
}

//
// Result, Ok, Err ???
//
Ok = type<T> { .v: Option[T] }
Err = type>E? { .e: Option[E] }
Result = enum<T, E> (Ok[T] | Err[E])

//
// Option, Some, None !!!
//
