//
// auto initialization
//
v0: int
v0 == 0

//
// manual initialization
//
v1: int = 0
v1 == 0

//
// single param function only
//
f0 = int -> int {
    _ + 2
}

r0: int = f0 1
r0 == 3

//
// tuple - anonymous product type
//
T: (int, int)
v: T = (1, 2)

// assignment by destruction
a: int, b: int = v
a: int, b: int = v[0], v[1]

//
// tuple - product type
//
T: (x: int, y: int)
v: T = (x=1, y=2)

// assignment by destruction
x: int, y: int = v
x: int, y: int = v.x, v.y
x: int, y: int = v[0], v[1]

//
// union - anonymous sum type
// types should not repeat, last overwrites last prop with same type
//
T: (int | float)
v0: T = 10
v1: T = -2.0

//
// union - sum type
// types should not repeat, last overwrites last prop with same type
//
T: (x: int | y: float)
v0: T = 10
v1: T = -2.0

//
// function - single param type, single return type 
//
f0: fn[int, int] = int -> int {
    _ + 1
}

f1 = int -> int {
    _ + 1
}

//
// function - default param and return types
//
f0: fn[object, object] = object -> object {
    _ + 1 // assume param type supports adding `1`
}

f1 = -> {
    _ + 1 // assume param type supports adding `1`
}

//
// tuple as param type of function
//
f0 = (int, int) -> int {
    _[0] + _[1]
}

a0: (int, int) = (1, 2)
r0: int = f0 a0
r0 == 3

r1: int = f0(1, 2)
r1 == 3

//
T: type = (int, int)

f0 = T -> int {
    _[0] + _[1]
}

a0: T = (1, 2)
r0: int = f0 a0
r0 == 3

//
// functions returning functions
//
f0: fn[int, fn[int, int]] = int -> fn[int, int] {
    a: int = _

    g0: fn[int, int] = int -> int {
        b: int = _
        a + b
    }

    g0
}

r0: int = f0 1 2
r0 == 4

//
f0: fn = int -> fn {
    a: int = _

    int -> int {
        b: int = _
        a + b
    }
}

r0: int = f0 1 2
r1: int = (f0 1 2)
r2: int = (f0 1) 2
r3: int = ((f0 1) 2)

//
// named function params without tuple usage
//
f0: fn = a: int -> b: int -> {
    a + b
}

r0: int = f0 1 2
r1: int = (f0 1 2)
r2: int = (f0 1) 2
r3: int = ((f0 1) 2)

//
// structural pattern matching - or just "match" 
//
T: type = (int, int)
U: type = (x: int, y: int)
V: type = (int | float)
W: type = (x: int | y: float)
P: type = T | U | V | W

a: T = (1, 2)
b: U = (2, y=3)
c: V = (1, 2.0)
d: W = (2, 3.0)
e: P + random.choice([a, b, c, d])

// manual match
Q: type = (x: int | float, y: int | float)

r: Q = type(e) == T ? {
        x: int, y: int = e
    } : type(e) == U ? {
        x: int, y: int = e
    } : type(e) == V ? (
        type(e) == V[0] ? {
            x: int = e
            y: float = 0
        } : type(e) == V[1] ? {
            x: int = 0
            y: float = e
        }
    ) : type(e) == W ? {
        type(e) == W.x ? {
            x: int = e
            y: float = 0
        } : {
            x: int = 0
            y: float = e
        }
    }

// semi-manual match
r: Q = match(
    e,
    T -> Q { x: int, y: int = e },
    U -> Q { x: int, y: int = e },
    V -> Q { x: int, y: float = e, 0 },
    W -> Q { x: int, y: float = 0, e },
)
