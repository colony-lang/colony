
/*
 * product types
 */

// tuples
let x: (i32, i32, i32) = (1, 2, 3)
// x == (1, 2, 3)

x[0] == 1
x[1] == 2
x[2] == 3

x = (x[0] * 2, x[1] * 3, x[2] * 4)
// x == (2, 6, 12)

// BAD: type Vec3 { i32, i32, i32 }
// BAD: let Vec3: Any = type { i32, i32, i32 }
let Vec3t: Any = (i32, i32, i32)

let v0: Vec3t = Vec3(1, 2, 3)
let v1: Vec3t = Vec3(9, 8, 7)

let Vec3nt: Any = (x: i32, y: i32, z: i32)

let v2: Vec3 = Vec3nt(1, 2, 3)
let v3: Vec3 = Vec3nt(9, 8, 7)

v0 == v2 == true
v1 == v3 == true

let Vec3gt: Type<T> = <T>(x: T, y: T, z: T)
let y0: Vec3gt<i32> = <i32>(1, 2, 3)
x0 == y0 == true

// structs
struct Vec3s {
    x: i32
    y: i32
    z: i32
}

let Vec3s: Any = struct {
    x: i32
    y: i32
    z: i32
};

let v4: Vec3s = Vec3s(1, 2, 3)
let v5: Vec3s = Vec3s(9, 8, 7)

v0 == v2 == v4 == true
v1 == c3 == v5 == true

struct Nil;

struct Node<T> {
    value: T
    next: Nil | Node<T>
}

let Node: Type = struct <T> {
    value: T
    next: Nil | Node<T>
}

/*
 * sum types
 */
struct Nil;
let Node: Type<T> = Nil | <T>(value: T, next: Node<T>)

let x0: Node<i32> = Nil                     // x0 = None
let x1: Node<i32> = (10, Nil)               // x1 = [10]
let x2: Node<i32> = (20, (10, Nil))         // x2 = [20, 10]
let x3: Node<i32> = (30, (20, (10, Nil)))   // x3 = [30, 20, 10]

/*
 * algebraic data types (ADT) - type calculus
 */
let T0: Type = (i32, i32, i32)
let T0_1: Type = (i32,)
let T0_2: Type = (i32, i32)
let T1: Type = T0_1 & T0_2 // (i32, i32, i32)
T0 == T1

let S0: Type = i32 | (i32,)
let S1_0: Type = i32
let S1_1: Type = (i32,)
let S1: Type = S1_0 | S1_1 // i32 | (i32,)
S0 == S1

let x0: S0 = 1
let x1: S0 = (1,)
x0 == x1 == false
x0 == x1[0] == true
