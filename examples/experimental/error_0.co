
__ctx__.on_error = (ctx: Ctx, error: Ere) -> None {
    println('Context: {}, error: {}', ctx, error)
    0.0
}

a: float = 1.0
b: float = 0.0

c: float = a / b    // panics
                    // go to __ctx__.on_error
                    // it will print context and error objects
                    // and resume after that and returns `0.0`

d: float = b / a

// another idiomatic approach is to use `try` builtin function
// try a / b, if it fails then return 0
c: float = try(a / b, default=0.0)

c: float = try(a / b, (error: Err) -> float {
    Err(e) := error
    
    e == 'ZeroDivision' ? {
        Infinite
    } : {
        NaN
    }
})

c: float = try(a / b, (err) -> {
    0.0
})

// NOTE: idea
c: Result[float, Error] = try(() -> {
    1 / 0
})

c0: float = c.unwrap(0.0)
c1: float = instanceof(c, ZerpDivision) ? Infinite : NaN

c1: float = byinstanceof(c, {
    ZerpDivision: Infinite,
    _: NaN,
})

c2: float = {
    ZeroDivision: Infinite,
}.get(typeof(c), NaN)

c3: float = typeof(c) == ZeroDivision ? Infinite : NaN

