
f1 := (x: f32, y: f32) -> f32 {
    x / y
}

f2 := (x: f32, y: f32) -> Result[f32] {
    y == 0 ? {
        ZeroDivisionError()
    } : {
        Ok[f32](x / y)
    }
}

v0: Result[f32] = try(() -> { f1(1.0, 0.0) })
v1: Result[f32] = try(f1, (1.0, 0.0))

a := match(try(f1, (1.0, 0,0)))
    .case(Ok[f32], (o) -> { o.unwrap() })
    .case(ZeroDivisionError, (o) -> { Infinite })
    .default((o) -> { NaN })

b := try_match(f1, (1.0, 0.0))
    .case(Ok[f32], (o) -> { o.unwrap() })
    .case(ZeroDivisionError, (o) -> { Infinite })
    .default((o) -> { NaN })

c := match(f2(1.0, 0.0))
    .case(Ok[f32], (o) -> { o.unwrap() })
    .case(ZeroDivisionError, (o) -> { Infinite })
    .default((o) -> { NaN })

d := match(f2(1.0, 0.0))
    .case(Ok[f32])  // implicit unwrap
    .case(ZeroDivisionError, Infinite)  // default non-callable value
    .default(NaN)   // implicite value

