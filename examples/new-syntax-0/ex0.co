//
// lisp-like s-expressions
//

// no `return` stmt because it should act as expr
// no `yield` stmt because it should act as expr

(fn f1 (x y z) (
    (/ (+ x y) z)
))

(= a (f1 1 2 3))

(= b 
    (if (== a 1)
        (true)
    (if (== a 2)
        (false)
        (None)
    ))
)

//
// c-like c-expressions
//

// primitive values
a = None // None, important for Optional generic type
b = true // Bool
c = false // Bool
d = 1 // Int
e = 1.1 // Float
f = 'abc123'  // Str, utf8 encoded string
g = b'abc123' // Bytes, b-bit bytes/strings without encoding
h = [] // List
i = {} // Dict
j0 = ^{ d * 2 } // Block/Closure
j1 = fn (a, b, c=0, *args, **kwargs) j0 // Fn
j2 = fn (a, b, c=0, *args, **kwargs) { None } // Fn
k = Namespace(...) // Namespace is used for Modules, "objects", etc
                   // usually created by `import()`
l = 

/*
Blocks are a language-level feature added to Colony
which allow you to create distinct segments of code
that can be passed around to functions as if they were values.
Blocks are Colony objects which means they can be added to
collections like Array or Dict.

They also have the ability to capture values from the
enclosing scope, making them similar to closures or lambdas
in other programming languages.
*/

f1 = fn (x, y, z) {
    (x + y) / z
}

a = f1(1, 2, 3)

b = if (a == 1) {
    true
} else if (a == 2) {
    false
} else {
    None
}
