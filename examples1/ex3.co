//
// Object/Type
//
let Object: mut.Dict = mut.Dict()
let Type: mut.Dict = mut.Dict()

// Object
Object.__name__ = "Object"
Object.__type__ = Type

Object.__new__ = Method(fn __new__(tp: Type, [args], {kwargs}) -> Object {
    // args and kwargs are not used at all but should
    let self: cls = {
        .__type__: tp,
        ...Dict.from_pairs(tp.map(fn(k, v) {
            if typeof(k) == Field {
                // what about field_type
                return v.field_value
            } else if typeof(v) == Method {
                return v.method_func
            } else {
                return v
            }
        }))
    }

    return self
})

Object.__init__ = Method(fn __init__(self: Object, [args], {kwargs}) -> Object {
    return self
})

// Type
Type.update(Object)
Type.__name__ = "Type"
Type.__type__ = Type

Type.__call__ = Method(fn __call__(cls: Type, [args], {kwargs}) -> Object {
    let self = cls.__new__(...args, ...kwargs)
    self = self.__init__(...args, ...kwargs)
    return self
})

// make immutable Object and Type
Object = Object.imut()
Type = Type.imut()

// Field
type Field: Object {
    fn __init__(self: Field, field_type: Type, field_value: Option[Object]) -> Field {
        self.field_type = field_type
        self.field_value = field_value
        return self
    }
}

// Method
type Method: Object {
    fn __init__(self: Method, method_func: Fn) -> Method {
        self.method_func = method_func
        return self
    }
}

//
// A
//
let A = {
    ...Object, // ...other1, ...other2
    .__bases__: [Object],   // list of bases, used for type-checking only
    .__name__: "A",
    .x: Field(f64, 0.0),
    .y: Field(f64, 1.0),
    .__init__: Method(fn __init__(self: A, x: f64, y: f64) -> A {
        self.x = x
        self.y = y
        return self
    }),
    .__add__: Method(fn __add__(self: A, other: A) -> A {
        let res: A = A.new(self.x + other.x, self.y + other.y)
        return res
    }),
}

//
// A
//
type A: Object {
    x: f64 = 0.0
    y: f64 = 1.0
    
    fn __init__(self: A, x: f64, y: f64) -> A {
        self.x = x
        self.y = y
        return self
    }
    
    fn __add__(self: A, other: A) -> A {
        let res: A = A.new(self.x + other.x, self.y + other.y)
        return res
    }
}

let a0: A = A(0.0, 1.0) // A.__call__(0.0, 1.0)
let a1: A = A(1.0, 2.0) // A.__call__(1.0, 2.0)
let a2: A = a0 + a1     // a0.__add__(a1)
