let b0: Array[i64] = [0, 1, 2, 3, 5, 8, 13]

let c0: Dict[str, i64] = {"a": 0, "b": 1, "c": 2}
let c1: Dict<T, V> = {0.0: false, 1.0: true}

//
//
//
let Object = mut.Dict()
let Type = mut.Dict()

Object.__name__ = "Object"
Object.__type__ = Type

Object.__new__ = fn(cls: Type, [args], {kwargs}) -> Object {
    let self = {
        .__type__: cls,
    }

    return self
}

Object.__init__ = fn(self: Object, [args], {kwargs}) -> Object {
    return self
}

Type.update(Object)
Type.__name__ = "Type"
Type.__type__ = Type

Type.__call__ = fn(cls: Type, [args], {kwargs}) -> Object {
    let self = cls.__new__(...args, ...kwargs)
    self = self.__init__(...args, ...kwargs)
    return self
}

Object = Object.imut()
Type = Type.imut()

//
//
//
let A = {
    ...Object,
    .__bases__: [Object],   // list of bases, used for type-checking only
    .__name__: "A",
    .x: field(f64, 0.0),
    .y: field(f64, 1.0),
    .__init__: fn(self: A, x: f64, y: f64) -> A {
        self.x = x
        self.y = y
        return self
    },
    .__add__: fn(self: A, other: A) -> A {
        let res: A = A.new(self.x + other.x, self.y + other.y)
        return res
    },
}

let a0: A = A(0.0, 1.0) // A.__call__(0.0, 1.0)
let a1: A = A(1.0, 2.0) // A.__call__(1.0, 2.0)
let a2: A = a0 + a1     // a0.__add__(a1)
