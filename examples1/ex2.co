//
//
//
let Object: mut.Dict = mut.Dict()
let Type: mut.Dict = mut.Dict()

// Object
Object.__name__ = "Object"
Object.__type__ = Type

Object.__funcs__ = {
    .__new__: fn(tp: Type, [args], {kwargs}) -> Object {
        let self: cls = {
            .__type__: tp,
            ...cls.__fields__,
        }

        return self
    },
    .__init__: fn(self: Object, [args], {kwargs}) -> Object {
        return self
    },
}

// Type
Type.update(Object)
Type.__name__ = "Type"
Type.__type__ = Type

Type.__funcs__ = {
    .__call__: fn(cls: Type, [args], {kwargs}) -> Object {
        let self = cls.__new__(...args, ...kwargs)
        self = self.__init__(...args, ...kwargs)
        return self
    },
}

// make immutable Object and Type
Object = Object.imut()
Type = Type.imut()

//
//
//
let A = {
    ...Object,
    .__bases__: [Object],   // list of bases, used for type-checking only
    .__name__: "A",
    .__fields__: {
        .x: field(f64, 0.0),
        .y: field(f64, 1.0),
    },
    .__funcs__: {
        .__init__: fn(self: A, x: f64, y: f64) -> A {
            self.x = x
            self.y = y
            return self
        },
        .__add__: fn(self: A, other: A) -> A {
            let res: A = A.new(self.x + other.x, self.y + other.y)
            return res
        },
    },
}

type A: Object {
    x: f64 = 0.0
    y: f64 = 1.0
    
    fn __init__(self: A, x: f64, y: f64) -> A {
        self.x = x
        self.y = y
        return self
    }
    
    fn __add__(self: A, other: A) -> A {
        let res: A = A.new(self.x + other.x, self.y + other.y)
        return res
    }
}

let a0: A = A(0.0, 1.0) // A.__type__.__funcs__.__call__(0.0, 1.0)
let a1: A = A(1.0, 2.0) // A.__type__.__funcs__.__call__(1.0, 2.0)
let a2: A = a0 + a1     // a0.__type__.__funcs__.__add__(a1)
