//
// object/type - implemented low-level in C
//
object := MutTuple()
type := MutTuple()

object.__type__: type = type
object.__name__: str = 'object'
object.__generics__: list[str] = []
object.__specifics__: dict[str, type] = {}
object.__bases__: list[type] = []
object.__fields__: tuple = ()
object.__functions__: dict[str, callable] = {}

type.__type__: type = type
type.__name__: str = 'type'
type.__generics__: list[str] = []
type.__specifics__: dict[str, type] = {}
type.__bases__: list[type] = [object]
type.__fields__: tuple = ()
type.__functions__: dict[str, callable] = {}

object.__functions__.__new__ = (cls: type) -> object {
    // implemented as native code
    pfields = _.__pfields__
    kwfields = _.__kwfields__

    self: object = (
        __type__: type=cls,
        ...zip(cls.__fields__.keys(), cls.__fields__.types(), pfields),
        ...kwfields.items().slice(pfields.len(), kwfields.len()),
    )

    self
}

object.__functions__.__free__ = (self: object) -> object {
    // implemented as native code
    //  frees dependent resources
    //  after this call, `self` is freed by memory allocator
}

object.__functions__.__repr__ = (self: object) -> str {
    // implemented as native code
    res: str = '<{} at {}>'.format(self.__type__.__name__, addressof(self))
    res
}

type.__functions__.__new__ = (mcs: type, name: str, generics: list[str], specifics: dict[str, type], bases: list[type], fields: dict[str, object], functions: dict[str, object]) -> type {
    // implemented as native code
    cls: object = (
        __type__: type = mcs,
        __name__: str = name,
        __generics__: list[str] = generics,
        __specifics__: dict[str, type] = specifics,
        __bases__: list[type] = bases,
        __fields__: tuple = fields,
        __functions__: dict[str, callable] = functions,
    )

    cls
}

type.__functions__.__call__ = (obj: object) -> object {
    // implemented as native code
    match(
        obj,
        (cls: type, name: str) -> type {
            // name
            (
                ...cls,
                __name__: str = name,
            )
        },
        (cls: type, generics: list[str]) -> type {
            // generics
            (
                ...cls,
                __generics__: list[str] = generics,
            )
        },
        (cls: type, specifics_or_bases: list[type]) -> type {
            cls.__fields__ || cls.__functions__ ? (
                // specifics
                ...cls,
                __specifics__: dict[str, type] = dict(zip(cls.__generics__.keys(), specifics_or_bases)),
            ) : (
                // bases
                ...cls,
                __bases__: list[type] = [object] + specifics_or_bases,
            )
        },
        (cls: type, fields_and_functions: tuple) -> type {
            // fields and functions
            (
                ...cls,
                __fields__: tuple = tuple(fields_and_functions.filter((k, t, v) => !iscallable(v))),
                __functions__: dict[str, callable] = dict(fields_and_functions.filter((k, t, v) => iscallable(v)).map((k, t, v) => (k, v))),
            )
        },
        (cls: type) -> object {
            pfields = _.__pfields__
            kwfields = _.__kwfields__

            // instance
            self: cls = cls.__functions__.__new__(cls, ...pfields, ...kwfields)
            self
        }
    )
}

object.freeze()
type.freeze()

//
// user-defined type using generics
//
// Q = type (
// Q = type ['X', 'Y'] (
// Q = type 'Q' ['X', 'Y'] (
Q = type 'Q' ['X', 'Y'] [object] (
    x: X,
    y: Y,

    __add__ := (self: Q, other: Q) -> Q {
        res: Q = Q[X, Y](x=self.x + other.x, y=self.y + other.y)
        res
    },

    __sub__ := (self: Q, other: Q) -> Q {
        res: Q = Q[X, Y](x=self.x - other.x, y=self.y - other.y)
        res
    },

    add := (self: Q, other: Q) -> Q {
        res: Q = self + other
        res
    },
)

q0: Q = Q[float, float](1.0, 2.0)
q1: Q = Q[float, float](2.0, 3.0)
q2: Q = q0.add(q1)
q3: Q = q0 + q1
