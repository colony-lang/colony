//
//
//
object := MutDict()
type := MutDict()

object.__name__ = 'object'
object.__type__ = type
object.__bases__ = []
object.__generics__ = None    // Option(list)
object.__specifics__ = None   // Option(dict)

object.__new__ = (cls, [args], {kwargs}) -> {
    self: cls = {
        .__type__: cls,
    }

    self
}

object.__init__ = (self, [args], {kwargs}) -> {
    // FIXME: self.__type__.__fields__
    self
}

object.__del__ = (self) -> {
    // free self after all its internal structures are dereferenced
}

type.__name__ = 'type'
type.__type__ = type
type.__bases__ = [object]
type.__generics__ = None    // Option(list)
type.__specifics__ = None   // Option(dict)

type.__getitem__ = (cls: type, [args]) -> Result[type, object] {
    // generics
    if cls.__generics__.len() != args.len() {
        return Error("number of generics and specificied types do not match")
    }

    cls = {
        ...cls,
        .__specifics__: zip(cls.__generics__, args).dict(),
    }

    cls
}

type.__call__ = (cls: type, [args], {kwargs}) -> {
    self: cls = cls::__new__(cls, ...args, ...kwargs)
    self = cls::__init__(self, ...args, ...kwargs)
    self
}

object.freeze()
type.freeze()

//
//
//
/*
A := type({
    .__name__: 'A',
    .__bases__: [],
    .__generics__: ['X', 'Y'],
    
    .__fields__: {
        .x: 'X',
        .y: 'Y',
    },

    .__init__: (self: A, x: X, y: Y) -> A {
        self = (self.x = x)
        self = (self.y = y)
        self
    },

    .__add__: (self: A, other: A) -> A {
        res: A = A[X, Y](
            x: self.x + other.x,
            y: self.y + other.y,
        )

        res
    },

    .__sub__: (self: A, other: A) -> A {
        res: A = A[X, Y](
            x: self.x - other.x,
            y: self.y - other.y,
        )

        res
    },

    .add: (self: A, other: A) -> A {
        A[X, Y]::__add__(self, other)
    },

    .sub: (self: A, other: A) -> A {
        A[X, Y]::__sub__(self, other)
    },
})
*/

type A <X, Y> {
    x: X
    y: Y

    __init__(self: A, x: X, y: Y) -> A {
        self = (self.x = x)
        self = (self.y = y)
        self
    }

    __add__(self: A, other: A) -> A {
        res: A = A[X, Y](
            x: self.x + other.x,
            y: self.y + other.y,
        )

        res
    }

    __sub__(self: A, other: A) -> A {
        res: A = A[X, Y](
            x: self.x - other.x,
            y: self.y - other.y,
        )

        res
    }

    add(self: A, other: A) -> A {
        A[X, Y]::__add__(self, other)
    }

    sub(self: A, other: A) -> A {
        A[X, Y]::__sub__(self, other)
    }
}

a0: A = A[int, float](0, 1.0)
a1: A = A[int, float](1, 2.0)
a2 := a0 + a1
a3 := a0 - a1
