//
// primitive types
//
b: bool = true
i: int = 10
f: float = 20.0
s: str = 'abc123'

//
// collection types
//
//  collections are allocated on heap
//
a: List[int] = [0, 1, 2, 3]
d: Dict[str, float] = {'x': 0.0, 'y': 1.0}
d: Dict[str, float] = {.x: 0.0, .y: 1.0}

//
// tuple types
//
//  tuple types are allocated at heap, but tuple instances are allocated at stack
//
T: Type = Tuple {.x: int, .y: float}
t: T = T {.x: 1, .y: 2.0}

X: Type = Tuple {.x: int}
Y: Type = Tuple {.y: float}
T: Type = Tuple (X & Y)

// simplified syntax
T: Type = (x: int, y: float)    // type inference 
t: T = (x: 1, y: 2.0)           // type inference 

X: Type = (x: int)              // type inference 
Y: Type = (y: float)            // type inference 
T: Type = X & Y                 // type inference 

//
P: Type = (x: int, y: int, [args], {kwargs})
p0: P = (10, y: 20, 30, 40, w=50)
p0 == (x: 10, y: 20, args: [30, 40], kwargs: {.w: 50})

//
// union types
//
//  union types are allocated at heap, but union instances are allocated at stack
//
U: Type = Union {.x: int, .y: float}
u0: U = U {.x: 1}
u1: U = U {.y: 2.0}

X: Type = Tuple {.x: int}
Y: Type = Tuple {.y: float}
U: Type = Union (X | Y)
u0: U = U {.x: 1}
u1: U = U {.y: 2.0}

// simplified syntax
U: Type = (x: int) | (y: float)
u0: U = (x: 1)
u1: U = (y: 2.0)

X: Type = (x: int)
Y: Type = (y: float)
U: Type = X | Y
u0: U = (x: 1)
u1: U = (y: 2.0)

//
// functions
//
f0: fn = (x: int, y: int) -> int {
    x + y
}

f0(1, y: 2) == 3

//
P: Type = (x: int, y: int)

f1: fn = (a: P, b: P) -> P {
    res: P = (
        a.x + b.x,
        a.y + b.y,
    )

    res
}

f1(a: (1, 2), b: (2, 3)) == (3, 5)

//
// type / object
//
Object: MutDict = MutDict()
Type: MutDict = MutDict()

Object.__name__ = 'Object'
Object.__type__ = Type
Object.__bases__ = []

Type.__name__ = 'Object'
Type.__type__ = Type
Type.__bases__ = [Object]

Type.__call__ = (cls, [args], {kwargs}) -> Object {
    self: cls = {.__type__: cls}
    self
}

Object.inplace_imut()
Type.inplace_imut()

//
// user-defined types
//
A: Type = Type {
    .__init__: (self, x: int, y: int) -> A {
        self = {...self, .x: x, .y: y}
        self
    },

    .__add__: (self, other: A) -> A {
        res: A = A {.x: self.x + other.x, .y: self.y + other.y}
        res
    },

    .__sub__: (self, other: A) -> A {
        res: A = A {.x: self.x - other.x, .y: self.y - other.y}
        res
    },
}

a0: A = A(1, ...{y: 2})
a1: A = A(x: 1, y: 2)
a2: A = a0 + a1
