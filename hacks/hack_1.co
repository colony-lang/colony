// type-system
ST: type = struct
UT: type = union

s: struct = struct(x: f64, y: f64)
s: struct = struct(f64, f64)
u: union = union(i64, f64)

s: struct = (x: f64, y: f64)
s: struct = (f64, f64)
u: union = f64 | f64

struct == typeof((x: f64, y: f64))
struct == typeof((f64, f64))
type == typeof(struct)

union == typeof((f64 | f64))
type == typeof(union)

// struct
struct(x: f64, y: f64) == (x: f64, y: f64)
struct(x: f64, y: f64) == (f64, f64)    // ??
struct(f64, f64) == (x: f64, y: f64)    // ??
struct(f64, f64) == (f64, f64)

P: struct = (x: f64, y: f64)
P: struct = struct(x: f64, y: f64)
P := (x: f64, y: f64)

// function
f: fn(P, P) = P -> P {
    r: P = (x, y)
    r
}

p0: P = f(1.0, 2.0)
p1: P = f(2.0, 3.0)

// function
add: fn((P, P), P) = (self: P, other: P) -> P {
    r: P = (self.x + other.x, self.y + other.y)
    r
}

p2: P = add(p0, p1)

// define struct with methods
AddSub: struct = (
    __add__ := (self: P, other: P) -> P {
        r: P = (self.x + other.x, self.y + other.y)
        r
    },

    __sub__ := (self: P, other: P) -> P {
        r: P = (self.x - other.x, self.y - other.y)
        r
    }
)

P: struct = (x: f64, y: f64) <- AddSub

p0: P = P(1.0, 2.0)
p1: P = P(2.0, 3.0)
p2: P = p0 + p1
p3: P = p0 - p1

// union
union(i64, f64) == (i64 | f64)

n64: union = i64 | f64
n64: union = union(i64, f64)
n64 := i64 | f64

// generic struct with methods
Point2D := <T:=i64|f64> -> (x: T, y: T) <- (
    __add__ := (self: Point2D<T>, other: Point2D<T>) -> Point2D<T> {
        r: Point2D<T> = (self.x + other.x, self.y + other.y)
        r
    },

    __sub__ := (self: Point2D<T>, other: Point2D<T>) -> Point2D<T> {
        r: Point2D<T> = (self.x - other.x, self.y - other.y)
        r
    }
)

p0: Point2D<f64> = Point2D<f64>(1.0, 2.0)
p1: Point2D<f64> = Point2D<f64>(2.0, 3.0)
p2: Point2D<f64> = p0 + p1

// condition
a: i64 = (1 == 1) ? 1 : 0

b: f64 = (1 == 1) ? {
    -1.0
} : {
    -2.0
}

// range, filter, map, reduce
a: f64 = range(10)
            .filter((n) -> { n % 2 })
            .map((n) -> { float.from_int(n * 2) })
            .reduce(0.0, (acc, n) -> { acc + n })

//
// Option
//
NoneType: struct = ()
None: NoneType = NoneType() // unique None struct
Option: union = <T:=type> -> (T | NoneType)

o0: Option<i64> = 1.0
o1: Option<i64> = None

t0 := match(o0)
        .case(i64, (v) -> { v })
        .default(() -> { -1 })


//
// Result
//
Result: union = <T:=type, E:=type> -> (T | E)

Error: fn<(str,), Err> = (msg: str) -> Err {
    Err(kind=Error, msg=msg)
}

ZeroDivisionError: fn<(str,), Err> = (msg: str="division by zero") -> Err {
    Err(kind=ZeroDivisionError, msg=msg)
}

r0: Result<i64, Err> = 1.0
r1: Result<i64, Err> = ZeroDivisionError()

t1 := match(r0)
        .case(i64, (v) -> { v })
        .case(Err, (k, e) -> { -1 })
        .default(() -> { -2 })

//
// ????
//


//
// Option
//
Some: struct = <T:=type> -> (v: T)
None: struct = () // unique None struct
Option: union = <T:=type> -> (Some<T> | None)

o0: Option<i64> = Some<i64>(1.0)
o1: Option<i64> = None

//
// Result
//
Ok: struct = <T:=type> -> (v: T)
Err: struct = <E:=type> -> (e: E)
Result: union = <T:=type, E:=type> -> (Ok<T> | Err<E>)

BaseError: struct = (msg: str)
ValueError: struct = (msg: str)
KeyError: struct = (msg: str)
AttributeError: struct = (msg: str)
ZeroDivisionError: struct = (msg: str)
Error: union = BaseError | ValueError | KeyError | AttributeError | ZeroDivisionError

r0: Result<i64, Error> = Ok<i64>(1.0)
r1: Result<i64, Error> = Err<ZeroDivisionError>("zero division")

// match-case
t0 := match(o0)
        .case(i64, (v) -> { v })
        .default(() -> { -1 })

t1 := match(r0)
        .case(i64, (v) -> { v })
        .case(Error, (e) -> { -1 })
        .default(() -> { -2 })

//
// type internals
//
P: struct = (/*__name__: str="P", __type__: type=struct,*/ x: f64, y: f64)

Error: struct = (/*__name__: str="Error", __type__: type=struct,*/ msg: str, kind: Any=Error)

ZeroDivisionError: fn = (msg: str) -> Error {
    err: Error = Err
}
