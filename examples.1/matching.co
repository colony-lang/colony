//
// structural pattern matching - or just "match" 
//
T: type = (int, int)
U: type = (x: int, y: int)
V: type = (int | float)
W: type = (x: int | y: float)
P: type = T | U | V | W

a: T = (1, 2)
b: U = (2, y=3)
c: V = (1, 2.0)
d: W = (2, 3.0)
e: P + random.choice([a, b, c, d])

// manual match
Q: type = (x: int | float, y: int | float)

r: Q = type(e) == T ? {
        x: int, y: int = e
    } : type(e) == U ? {
        x: int, y: int = e
    } : type(e) == V ? (
        type(e) == V[0] ? {
            x: int = e
            y: float = 0
        } : type(e) == V[1] ? {
            x: int = 0
            y: float = e
        }
    ) : type(e) == W ? {
        type(e) == W.x ? {
            x: int = e
            y: float = 0
        } : {
            x: int = 0
            y: float = e
        }
    }

// semi-manual match
r: Q = match(
    e,
    T -> Q { x: int, y: int = e },
    U -> Q { x: int, y: int = e },
    V -> Q { x: int, y: float = e, 0 },
    W -> Q { x: int, y: float = 0, e },
)
